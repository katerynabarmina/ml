
У сучасному світі швидкозмінний технологічний ландшафт вимагає постійного удосконалення підходів до розробки програмного забезпечення. Один із основних напрямків цієї еволюції включає в себе перехід від традиційної монолітної архітектури до більш гнучкої та розгалуженої мікросервісної архітектури. Популярність переходу на мікросервісну, архітектуру обумовлено великою кількістю проблем, які виникають у зв'язку з роботою з монолітною архітектурою. Одною з яких є, наприклад,  важкость масштабування. У великих додатках, побудованих на монолітній архітектурі, може виникати ситуація, коли потрібно масштабувати лише певні його частини. Наприклад, якщо певний модуль перевантажений запитами, а інший - ні, монолітна архітектура вимагає масштабування всього додатку, що може бути неефективним та надто затратним. Крім того, розробка у монолітній архітектурі може бути обмеженою використанням конкретних технологій та інструментів. Оскільки весь додаток споруджується як єдиний блок, використання різних мов програмування або фреймворків може бути складним або неможливим. Це може призвести до ситуації, коли для виконання певної функціональності доводиться компромісно використовувати технології, які не є оптимальними. Це лише кілька проблем, які можуть виникати під час використанням монолітної архітектури і які може вирішити мікросервісна архітектура.
Об'єктом дослідження є процес переходу додатку з монолітної архітектури на мікросервісну на платформі Java.  Поглиблене вивчення цього процесу стає ключовим для розуміння переваг та викликів, з якими стикаються розробники програмного забезпечення при переході до більш сучасної та гнучкої архітектури.
Предметом дослідження є конкретні аспекти переходу з монолітної на мікросервісну архітектуру на платформі Java, а саме: аналізі технічних вирішень трансформації на мікросервісну архітектуру на платформі Java, вирішенні викликів її імплементації, виявленні переваг і недоліків, а також надання рекомендацій щодо оптимального моменту для зміни та альтернативних варіантів архітектурного розвитку. Вивчення цих аспектів дозволить глибше розібратися в мікросервісної архітектурі та визначити її доцільність для конкретного додатку.
Метою даної роботи є реалізація переходу на мікросервісну архітектуру та покращення ефективності, стресостійкості та швидкості розробки додатку за допомогою цього.
Тема переходу на мікросервісну архітектуру є надзвичайно актуальною через зростаючу складність сучасних програмних додатків. Сьогоднішні додатки стають все більш великими та складними, з багатою функціональністю та взаємодією між їх компонентами. Щоб бути конкурентоспроможними та задовольняти швидко зростаючі потреби користувачів, нові функції та зміни повинні бути впроваджені у додаток швидко та ефективно. При цьому застосунок не має втрачати надійність і бути стресостійким до збільшення навантаження. Мікросервісна архітектура вирішує ці проблеми та стає ефективним рішенням для розвитку та підтримки складних програмних застосунків у вимогливих умовах ринку.
 
1	АНАЛІЗ МІКРОСЕРВІСНОЇ ТА МОНОЛІТНОЇ АРХІТЕКТУР

1.1 Монолітна архітектура
Монолітна архітектура – архітектура, при якому всі компоненти додатку розміщуються в одному кодовому модулі або програмі. Ця архітектура виникла на початку 20-го століття, коли почали з'являтися перші комп'ютери, програми були написані в одному комплексі, де весь код зберігався у вигляді одного великого блоку, часто називаного "монолітом". Ця архітектура була дуже зручна тим, що весь програмним код знаходився у одному місці. Така архітектура має наступні характеристики [1]:
1)	одинична модель розгортання;
2)	централізований потік керування;
3)	тісна взаємодія;
4)	спільний доступ до пам'яті;
5)	однорідний технологічний стек.
Стандартна монолітна архітектура складається з декількох шарів. Схему стандартної монолітною архітектури можна побачити на рисунку 1.1.



Рисунок 1.1 – схема стандартної монолітної архітектури
 Перший з цих шарів – це презентаційний шар. Презентаційний шар відповідає за взаємодію з користувачем і включає в себе всі веб-сторінки та інші ресурси, які користувачі бачать і з якими взаємодіють. Цей шар забезпечує інтерфейс, через який користувачі отримують доступ до функціоналу програми.  Наступний важливий шар – це шар бізнес-логіки. Цей шар містить реалізацію основних функцій програми та відповідає за обробку даних, виконання правил і реалізацію бізнес-логіки. Тут відбувається більшість процесів, що забезпечують роботу програми згідно з вимогами бізнесу. Код у цьому шарі обробляє вхідні дані з презентаційного шару, застосовує необхідні алгоритми і логіку, приймає рішення та передає результати далі, зазвичай до шару даних. Основна задача цього шару – реалізувати функціонал програми, забезпечити правильну обробку даних та виконання всіх бізнес-правил, що стосуються конкретної задач.
Останнім, але не менш вважливим, є частина додатку, яка відповідає за зберігання та доступ до даних. Це включає базу даних, API та інші ресурси, які використовуються для зберігання та доступу до даних програми.
1.1.1 Переваги монолітної архітектури
Незважаючи на широку популярність мікросервісів, монолітні рішення продовжують зберігати свою привабливість та активно використовуються у сучасних проектах. Це особливо помітно у сфері стартапів, де багато молодих компаній обирають саме цей підхід для початкового етапу свого розвитку. І хоча мікросервіси можуть здаватися більш сучасним та гнучким варіантом, монолітна архітектура зберігає свої переваги, які буде розглянуто нижче.
Легкість розробки. У порівнянні з мікросервісами, де необхідно мати глибоке розуміння взаємодії сервісів між собою, монолітний підхід виглядає більш зрозумілим та простим. Вся кодова база знаходиться в одному місці, дозволяючи спросити розробку, бо немає необхідності вивчення складних механізмів взаємодії компонентів. Також вважливо зазначити, що ця архітектура ідеально підійде до стартапів, бо одна або кілька невеликих команд зможуть ефективно працювати над усім додатком, не розподіляючи його на декілька незалежних частин.
Легкість у внесенні радикальних змін. Можна змінити структуру бази даних, коду в декількох модулях проекту і розгорнути отриманий результат.
Просте розгортання. Розгортання монолітної архітектури включає розгортання єдиного блоку, що є менш складним і потребує менше конфігурацій, порівняно з розподіленими системами, а також включає меншу кількість залежностей. Тому це призводить до швидшого розгортання. Потрібно розгортати лише один блок, наприклад, war-файл.
Спрощене тестування та відлагодження. Тестування монолітного додатку є менш складним завдяки щільній інтеграції всіх компонентів. Оскільки усі тести компонентів та інтеграції можна проводити в межах єдиної кодової бази, процес тестування займає менше часу. З однією  кодовою базової легше відстежувати робочі процеси та відлагоджувати проблеми.
Універсальна масштабованість. Ця архітектура надає можливість ефективно масштабувати додаток, особливо для невеликих та середніх за розміром проектів. Це можна досягти шляхом реплікації всієї програми, тобто створення її копій для забезпечення потрібної пропускної здатності та обробки завдань. Через те, що створювати копії додатку відносно просто,  це дозволяє ефективно підтримувати його продуктивність при збільшенні обсягів обробки даних або навантаження на сервери. Завдяки такому масштабуванню монолітний додаток може ефективно зростати разом з розвитком бізнесу або збільшенням обсягів користувачів.
1.1.2 Недоліки монолітної архітектури
Хоча монолітна архітектура має свої переваги, її використання також пов'язане з рядом недоліків, які і є зазвичай причиною для переходу на мікросервісну архітектуру. Розглянемо основні проблеми, що можуть виникнути при використанні цього підходу до розробки програмного забезпечення на прикладі  додатку компанії FTGO з книги Криса Ричардсона «Мікросервісна архітектура» [2].
Компанія FTGO була заснована у 2005 році, дуже стрімко розвивалась та на той момент була лідером на американському ринку доставки їжі. Спочатку додаток був досить простим і мав монолітну архітектуру з якою, на той час, не виникало проблем. З роками, обростаючи новими функціями і випускаючи нові версії, розмір додатку значно збільшився. Розробниками FTGO становилось все складніше підтримувати кодову базу і вона перетворилась на анти-шаблон під назвою «великий комок бруду». Як сказали самі автори шаблону, Брайан Фут та Джозеф Йодер: "Більший комок грязі - це безладно структурований, розтягнутий, небрежний, майже на ходу зроблений з використанням ізоленти та дроту, джунглі кодового спагетті. Ці системи проявляють безперечні ознаки неконтрольованого зростання та постійних покращень. Інформація розподіляється безладно між віддаленими елементами системи, часто до такої міри, що майже вся важлива інформація стає глобальною або дублюється. Загальна структура системи, можливо, ніколи не була чітко визначена. Якщо і була, то стала розмитою до невпізнаваності. Програмісти, які хоча б трохи розуміють архітектуру, обходять цю болотну ділянку стороною. І тільки ті, кому це мало цікаво і, можливо, ті, кому подобається заклеювати дірки в системі щодня, задоволені роботою над такими системами".
Додаток став надто складним з великою кількістю заплутаних залежностей між класами. Це зробило майже неможливим зрозуміти його для одного розробника. Внаслідок цього додавання нових можливостей та відстеження існуючих проблем займало значну кількість часу. Така складність робила проект менш прозорим, а нові зміни не завжди вводилися коректно. Постійні вдосконалення та виправлення проблем стали нудними та часом затратними процесами.
Крім експоненціального зростання складності, FTGO із затримкою стикнувся і сам процес розробки. Інтегровані середовища розробки програмістів були сповільнені і перевантажені через розмір проекту. Збірка коду, запуск проекту, проходження всіх тестів – все це щоденно займало чималий, дорогоцінний для розробників, час, що сприяло зниженню продуктивності.
Розгортка додатку теж притерпіла незбіжних змін і стала досить важким процесом. Доставка змін в промислову середу, як правило, відбувалось раз на місяць. Велика кількість розробників працювали над одною кодовою базою, що найчастіше призводило до неможливості випустити зборку. Приходилось витрачати неабиякий час на діагностику та стабілізацію перед тим як випустити нову версію.
Проблеми були із масштабуванням. Одному модулю потрібно було більше обчислювальних ресурсів для обробки великої кількості замовлень у пікові години, тоді як інший компонент потребував більше пам'яті для ефективного зберігання та обробки даних користувачів. В результаті часто бувало, що у різніх компонентів FTGO були конфліктуючі вимоги до ресурсів, але через те, що це єдиний додаток працівникам приходилось йти на компроміс щодо конфігурацій серверів, щоб забезпечити оптимальне функціонування всього додатку.
Недостатня надійність. Як було зазначено раніше, додаток став «великим комком бруду». Одним із наслідків такого явище стала важкість тестування, відповідно в промислову середу попадала підсумкова версія з неполадками. Тому що FTGO мав монолітну архітектуру, йому не вистачало локалізації несправностей. Це сприяло тому, що час від часу, несправності в одному модулі вели по черзі до несправності інших.
Прив'язка до старого стеку технологій. Використати нову мову програмування або якійсь новий фреймворк, який би був сумісний з вже існуючим стекам технологій, було дуже важким завданням. Переписати весь монолітний проект було би дуже ризиковано та дорого. Це вимушувало програмістів або шукати технології, які будуть сумісні з існуючими, що не завжди були кращим рішенням для якоїсь конкретної проблеми, або якось вирішувати проблему за допомогою тих технологій та інструментів, які були обрані на старті проекту.
Дивлячись на цей приклад, можна виявити наступні недоліки у монолітному підході до розробки програмного забезпечення:
1)	складність масштабування;
2)	важкість утримання;
3)	залежність від старого стеку технологій;
4)	недостатня надійність.

1.2 Мікросервісна архітектура
У працях [4] мікросервісна архітектура – це тип архітектури, де додаток розбивається на слабопов'язані, незалежні сервіси, кожен з яких відповідає за свій функціонал. Щоб зрозуміти що таке сервіс потрібно спочатку дати визначення модульності. Модульність - розбиття системи на невеликі модулі, які виконують конкретні функції або задачі. В монолітній архітектурі модулями є окремий функціональний компонент або частина програмного забезпечення, яка має певний набір функцій та відповідальностей. У контексті мови програмування Java, модуль може бути представлений як пакет - це згруповання класів і інших ресурсів, які мають спільну функціональність або тематику і можуть бути використані разом.
В мікросервісній же архітектурі модуль – це сервіс. Сервіс – це міні-додаток, який реалізує вузькоспеціалізований функціонал. На відміну від пакетів, сервіси мають бар’єр у вигляді API, який не можна обійти щоб доступатись до якогось внутрішнього класу. Це сприяє підтриманню модульності додатку у довгостроковій перспективі.
Розподілені системи є потужним підходом до архітектури програмного забезпечення, який дозволяє ефективно масштабувати та забезпечувати високу доступність і надійність додатків. Для кращого розуміння концепції розподілених систем важливо розглянути ключові характеристики, які притаманні цьому виду архітектури. Ці характеристики роблять розподілені системи незамінними для сучасних високонавантажених і масштабованих програмних рішень.
Мікросервісна архітектура має наступні характеристики:
1) розбиття на невеликі, незалежні сервіси, кожен з яких відповідає за конкретну функціональність або послугу;
2) автономність, тобто що кожний з мікросервісів може бути розвинутий, тестований, відділений та масштабований незалежно від інших сервісів;
3) легка заміна та модифікація;
4) розподілене управління, кожен компонент має власну базу даних та власний набір інструментів для управління своєю конфігурацією та моніторингом;
5) гнучкість масштабування;
6) швидкість розробки;
7) стійкість до відмов.
Стандартна мікросервісна архітектури має схему, яка зазначена на рисунку 1.2 [3].


Рисунок 1.2 – спрощена схема стандартної мікросвервісної архітектури

На схемі можна побачити, що присутній так званий «шлюз», через який проходять всі запроси. Він виступає в якості маршрутизатора і вирішує якому сервісу відправити запит. Також в ньому зазвичай реалізована різна наскрізна логіка така як авторизація/аутентифікація і т.п. Можна побачити 4 незалежних сервісів, які відповідають за свій функціонал та можуть спілкуватись між собою за допомогою API або брокера повідомлень. Кожен сервіс має свою базу даних.

1.2.1 Переваги мікросервісної архітектури
Зараз мікросервісна архітектура здобуває все більшу популярність, і це не випадково. Для того, щоб зрозуміти, чому саме цей підхід вибирають такі гіганти як Amazon, Netflix, Uber, Spotify та інші, варто детальніше розглянути його переваги [5 - 6].
Одним із головних плюсів такої архітектури є можливість неперервної розгортки. Кожен сервіс в системі сфокусований суто на своїй функціональності, що робить створення автоматичних тестів значно простішим та ефективнішим. Внаслідок цього, кінцевий результат має меншу ймовірність містити помилки, а процес виправлення їх стає більш прозорим і швидким. Кожна команда відповідає за розробку одного або кількох конкретних сервісів і не потребує координації з іншими командами. Це розподіл роботи дозволяє командам працювати над своїми завданнями незалежно, що значно прискорює розвиток системи та впровадження нового функціоналу і відповідно оновлень.
Незалежне масштабування сервісів. Основна ідея полягає в тому, що кожен окремий сервіс може бути масштабований незалежно від інших, забезпечуючи оптимальне використання доступних ресурсів. Це дає змогу налаштувати кожен сервіс з урахуванням його власних потреб щодо обсягу пам'яті, потужності процесора та мережі. Наприклад, якщо один сервіс вимагає більше обчислювальних ресурсів, його можна масштабувати вертикально, збільшуючи кількість віртуальних машин або контейнерів. У той же час, якщо інший сервіс має високі вимоги до мережевої пропускної здатності, його можна масштабувати горизонтально, додаючи більше екземплярів сервісу. Це дозволяє оптимізувати використання ресурсів і забезпечити ефективність кожного сервісу навіть під час змінних навантажень. Завдяки незалежному масштабуванню сервісів, система може легко адаптуватись до змін у навантаженні та забезпечувати стабільну та ефективну роботу навіть у найвимогливіших умовах.
Відмовостійкість. Наприклад, якщо один із сервісів має витік пам'яті або інший технічний збій, це вплине тільки на роботу цього конкретного сервісу. Інші сервіси продовжать обробляти запити в звичайному режимі і не будуть залучені до проблем, що виникли в окремому сервісі. Це дозволяє підтримувати стабільну роботу системи навіть у разі виникнення проблем в окремих її складових.
Легке обслуговування сервісів. Кожен сервіс зазвичай є невеликим за розміром і сконцентрованим на конкретній задачі або області функціональності. Це дозволяє зберігати код сервісу у відносно невеликих та зрозумілих розмірах. Через свою автономність сервіс має мінімальну кількість залежностей від інших компонентів системи. Це уникне ситуацій, коли код перетворюється на "великий комок бруду", що ускладнює його обслуговування та розвиток. Для розробників це означає, що їм буде набагато легше розібратись в окремому сервісі, оскільки вони можуть сконцентруватись лише на його функціональності та коді. Крім того, інтегроване середовище розробки не буде має високого навантаження, оскільки для збирання та запуску проекту не потрібно компілювати або робити збірку всього коду системи, а лише окремого сервісу. Такий підхід сприяє прискоренню процесу розробки та зменшенню часу, потрібного на впровадження нового функціоналу або виправлення помилок.
Можливість впроваджувати нові технології та інструменти є ще однією перевагою мікросервісної архітектури. У відміну від монолітної архітектури, де впровадження нових технологій може вимагати перевірки сумісності фреймворків або навіть повного переписування всього проекту у разі використання іншої мови програмування, у розподілених системах цей процес відбувається значно легше. Оскільки кожен сервіс у мікросервісній архітектурі є незалежним, впровадження нових технологій може відбуватись без зайвих перешкод. Наприклад, один сервіс може бути написаним на Java, інший на Go, а третій на Python. Це дозволяє використовувати найбільш підходящі інструменти та мови програмування для конкретних завдань, що сприяє покращенню ефективності розробки.
Крім того, якщо нова технологія або інструмент не виправдає очікувань, її можна легко видалити без значного впливу на інші компоненти системи. Це дає можливість експериментувати та швидко адаптуватись до змін в технологічному середовищі без значних ризиків для проекту в цілому.

1.2.2 Недоліки мікросервісної архітектури
Жодна архітектура не є ідеальною, і мікросервісна архітектура не є винятком. Хоча вона має багато переваг, є і недоліки, які буде розглянуто нижче за книгою [2].                                                    				Важкість розбиття на сервіси. Розбиття на сервіси може виявитися складним завданням через відсутність чіткого алгоритму або шаблону для розподілу монолітної системи на окремі сервіси. Кожна система має свої унікальні вимоги, функціональність та залежності, тому не існує універсального методу для розбиття на сервіси. Це може призвести до ризику створення розподіленого моноліту, коли сервіси залежать один від одного або взаємно переплітаються. У такому випадку переваги мікросервісної архітектури, такі як незалежність та легкість масштабування, можуть бути знищені, а система може зазнати проблем, які притаманні як мікросервісній, так і монолітній архітектур.								Складність комунікації. Розробник стикаються з необхідністю розробки механізмів міжсервісної взаємодії. У монолітних застосунках комунікація між компонентами є досі простою, оскільки всі вони працюють в одному процесі і достатньо лише визвати метод потрібного класу. Проте у мікросервісній архітектурі кожен сервіс функціонує незалежно, і для здійснення комунікації між ними необхідно використовувати механізми, такі як HTTP запити, брокери повідомлень або інші технології та протоколи. Це ускладнює розробку, оскільки програмісти повинні стежити за правильністю реалізації механізмів комунікації, а також забезпечити обробку помилок та відмовостійкість у випадку недоступності або перевантаження сервісу.
Складність розгортання та управління. Кожен сервіс розглядається як окремий додаток, що потребує окремого розгортання та керування. Це може призвести до складнощів у конфігуруванні, моніторингу та керуванні великою кількістю сервісів.
Узгодженість даних при наявності у кожного сервіса окремої бази даних. У монолітній архітектурі програмного забезпечення, де всі компоненти системи об'єднані в одному місці і використовують одну спільну базу даних, підтримка узгодженості даних відносно проста. Завдяки централізованому контролю над даними, всі запити та оновлення даних виконуються в рамках однієї системи, що гарантує їхню синхронність. В розподілених системах кожен сервіс має свою власну базу даних, підтримка узгодженості даних стає значно складнішою. Ця складність виникає через те, що оновлення даних в одній базі даних не автоматично синхронізуються з іншими базами даних, що може призвести до невідповідностей та розбіжностей у даних. Для вирішення цієї проблеми зазвичай використовуються  різні паттерни та інструменти такі як CQRS, Saga Pattern, розподілені транзакції та інші.

1.3 Порівняння мікросервісної та монолітної архітектур
При виборі архітектури програмного забезпечення немає універсального ідеального варіанту. Кожен проект має свої унікальні вимоги, обмеження та контексти, які необхідно враховувати при прийнятті рішення. Хоча мікросервісна архітектура стає все більш популярною через свої численні переваги, такі як гнучкість, масштабованість та незалежність компонентів, вона не є універсальним рішенням для всіх проектів.
Рішення про те, яку архітектуру використовувати, залежить від перечні факторів, таких як:
	розмір та складність проекту;
	масштабованість;
	гнучкість;
	навички команди;
	бюджет.
Наприклад, для стартапів з обмеженим бюджетом це має кілька переваг.
По-перше, розгортання моноліту зазвичай менш складне, оскільки немає необхідності керувати кількома різними мікросервісами. Один блок коду може бути легко розгорнутий у вигляді war-файлу.
По-друге, керувати монолітом також простіше, оскільки немає необхідності координувати багато незалежних сервісів. Це означає, що можливо зосередитися на розробці функцій і вдосконаленні продукту, а не витрачати час на управління складною інфраструктурою.
По-третє, зменшуються витрати, оскільки для його підтримки потрібно менше апаратного та програмного забезпечення. Це значно зменшує загальні витрати на обслуговування та управління інфраструктурою.
З іншого боку, для великих компаній з обширною кодовою базою і великою кількістю інженерів мікросервісна архітектура може бути оптимальним рішенням з кількох причин.
По-перше, мікросервісна архітектура дозволяє розподіляти навантаження між різними командами розробників. Кожна команда може відповідати за розробку та підтримку власних сервісів. Це означає, що різні частини системи можуть розроблятися паралельно, не блокуючи одна одну і не чекаючи на інші команди.
По-друге, архітектура мікросервісів полегшує розширення системи. Кожен сервіс можна розгортати і розширювати незалежно, що полегшує адаптацію системи до зростаючих потреб. Наприклад, якщо популярність одного з сервісів зростає і він потребує більше ресурсів, масштабувати можна лише цей конкретний сервіс, не впливаючи на решту системи.
По-третє, мікросервісна архітектура полегшує обслуговування системи. Кожен сервіс може мати власну команду, відповідальну за його підтримку. Це дозволяє швидше виявляти, вирішувати та впроваджувати виправлення помилок, оскільки вони локалізуються в межах конкретного сервісу, а не поширюються на всю систему.
Отже, можна сказати, що зазвичай мікросервіси більше підходять до великий компаній, а моноліти для компаній, які тільки починають свій шлях. Основні відмінності архітектур можна побачити на таблиці 1.1.

Таблиця 1.1 – порівняння монолітної та мікросервісної архітектур
Аспект	Мікросевісна архітектура	Монолітна архітектура
Розробка та розгортання	Єдина кодова база, проста розробка та розгортання	Децентралізована розробка, кожна служба розробляється та розгортається незалежно
Масштабованість та продуктивність	Масштабування всього додатку, потенційне марнування ресурсів	Масштабованість кожного сервісу окремо, оптимальне виділення ресурсів на основі потреб служби
Підтримка та розширюваність	Єдина кодова база, легше зрозуміти та підтримувати	Незалежні служби, легше додавати нові функції без впливу на весь додаток

Продовження таблиці 1.1
Стійкість до помилок та стійкість	Єдина точка відмови, помилки впливають на весь додаток	Ізольовані відмови, краща стійкість до помилок та стійкість
Комунікація та координація	Прямі виклики функцій, проста комунікація та обмін даними	Міжсервісна комунікація, додаткові зусилля для координації та узгодженості даних
Різноманітність та автономність технологій	Обмежений стек технологій	Різноманітні технології для кожної служби, свобода вибору

В таблиці наведено порівняння по таким за такими аспектами як розробка та розгортання, масштабованість та продуктивність, підтримка та розширюваність, різноманітність та автономність технологій, стійкість до помилок та стійкість, а також комунікація та координація.
 